# [Silver II] 연속한 소수 만들기 - 21395 

[문제 링크](https://www.acmicpc.net/problem/21395) 

### 성능 요약

메모리: 28336 KB, 시간: 448 ms

### 분류

브루트포스 알고리즘, 그리디 알고리즘, 수학, 정수론, 소수 판정

### 제출 일자

2024년 11월 17일 11:20:39

### 문제 설명

<p>Albert는 최근 소수 (prime)에 대해 배웠다. 1보다 큰 양의 정수 p의 약수가 1과 p뿐인 경우 p를 소수라 한다. 만약 n개의 소수 p[1], p[2], ..., p[n] 이 아래 조건을 만족하면 이는 "연속한 소수" 라고 한다:</p>

<ul>
	<li>p[1], ..., p[n]이 n개의 고유한 (서로 다른) 소수이며</li>
	<li>min(p[1], ..., p[n]) <= q <= max(p[1], ..., p[n]) 을 만족하는 모든 정수 q에 대해 q가 소수이면 p[1], ..., p[n]중 하나와 같다.</li>
</ul>

<p>예를 들어 [5, 3, 2, 7]과 [11, 7, 5, 13]은 연속한 소수이며 [2, 5, 7]이나 [5, 13, 17] 혹은 [2, 2, 3, 5]는 연속한 소수가 아니다.</p>

<p>Albert는 혼자 할 수 있는 놀이를 생각하던 중, 소수 만들기 라는 게임을 해보기로 했다.</p>

<p>먼저 임의의 양의 정수 n개를 선택한다 (편의상 x[1], x[2], ..., x[n] 이라 하자). 이를 연속한 소수 n개로 바꾸고 싶은데, 아래와 같은 제약이 따른다.</p>

<ul>
	<li>각 정수 x[i]를 임의의 소수로 바꿀 수 있고, x[i]가 이미 소수인 경우라도 다른 소수로 바꿀 수 있다. (x[i]가 이미 소수인 경우, 바꾸지 않아도 된다.)</li>
	<li>어떤 정수 y를 임의의 소수 p로 바꾸는데 | p - y | 만큼의 벌점이 발생한다.</li>
</ul>

<p>예를 들어 n = 3 이고 x = [7, 13, 3]이라 하자.</p>

<ul>
	<li>이미 모든 수가 소수이지만, 연속한 소수가 아니다.</li>
	<li>이 세 정수를 [5, 7, 11]로 바꾸는 경우 벌점은 |5 - 7| + |7 - 13| + |11 - 3| = 16이 발생한다.</li>
	<li>다른 방법으로, x[2]를 13에서 11로 바꾸고 (벌점 2 발생) x[3]을 3에서 5로 바꾸면 (벌점 2 발생) 총 벌점은 4가 발생하고, 	결과로 [7, 11, 5]를 얻게 되는데 이는 연속한 소수이다 (순서는 상관 없음에 유의하자).</li>
</ul>

<p>다른 예로, n = 3 이고 x = [2, 2, 2]라 하자.</p>

<ul>
	<li>가령 첫 수를 3으로 바꾸고 마지막 수를 5로 바꾸면 벌점이 4 발생하고 결과로 [3, 2, 5]를 얻게 된다.</li>
</ul>

<p>입력으로 Albert가 처음에 고른 n개의 정수 x[1], ..., x[n]이 주어졌을 때, 이를 n개의 연속한 소수로 바꾸기 위해 필요한 최소한의 벌점을 구해보자.</p>

### 입력 

 <p>첫 줄에 테스트 케이스의 수 T가 주어진다.</p>

<p>각 테스트 케이스는 두 줄에 나누어 주어지는데 첫 줄에 n이 주어지고 다음 줄에 n개의 정수가 공백으로 구분되어 주어진다.</p>

### 출력 

 <p>각 테스트 케이스에 대해 입력으로 주어진 정수를 연속된 소수로 바꾸기 위해 필요한 최소한의 벌점을 각 줄에 출력한다.</p>

